"use strict";var e=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(o,a){function r(e){try{c(i.next(e))}catch(e){a(e)}}function s(e){try{c(i.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,s)}c((i=i.apply(e,t||[])).next())}))};const t=window.cc,n="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUGBgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYHCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wgARCAACAAIDAREAAhEBAxEB/8QAFAABAAAAAAAAAAAAAAAAAAAACf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAH8P/8QAFBABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQABPwB//8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAgBAgEBPwB//8QAFBEBAAAAAAAAAAAAAAAAAAAAAP/aAAgBAwEBPwB//9k=",i=new t.Vec2,o=new t.Vec3,a=80,r=16,s={onAnimationEffectEvent:"Effect",onAnimationDamageEvent:"Damage"};var c;!function(e){e[e.Hue=0]="Hue",e[e.Saturation=1]="Saturation",e[e.Brightness=2]="Brightness"}(c||(c={}));const l=["hue","saturation","brightness"],d=["R","G","B","A"],m=["USE_MASK_HSV_R","USE_MASK_HSV_G","USE_MASK_HSV_B","USE_MASK_HSV_A"];var A;function _(e){return e instanceof t.Vec4||e instanceof t.Color?[e.x,e.y,e.z,e.w]:e instanceof t.Vec3?[e.x,e.y,e.z]:e instanceof t.Vec2?[e.x,e.y]:e}function h(e){var t,n;return null!==(n=null===(t=e.match(/[^\\\/]+(?=\.\w+$)/))||void 0===t?void 0:t[0])&&void 0!==n?n:e}function g(e,n,i){const o=new Image;o.src=n,o.addEventListener("load",(()=>{const n=new t.Texture2D;n.image=new t.ImageAsset(o);let a=new t.SpriteFrame;if(a.texture=n,null!=i)for(const e of Object.keys(i))a[e]=i[e];e.spriteFrame=a}))}function v(e,n,i){const o=new t.Node(n);return o.layer=t.Layers.Enum.UI_2D,u(o,"cc.UITransform",i),null==e||e.addChild(o),o}function p(e,n,i,o){const a=u(e,t.Sprite,o);return null==(null==o?void 0:o.sizeModel)&&(a.sizeMode=t.Sprite.SizeMode.CUSTOM),g(a,n,i),a}function u(e,t,n){const i=e.addComponent(t);if(null!=n)for(const e of Object.entries(n))i[e[0]]=e[1];return i}function C(e,t,n){const i=e.getComponent("cc.UITransform");i.width=t,null!=n&&(i.height=n)}function f(e,n,i){for(const o of e.children){const e=t.Mat4.fromSRT(new t.Mat4,o.rotation,o.position,o.scale),a=null!=i?`${i}/${o.name}`:o.name;n.set(a,e),f(o,n,a)}}function E(e,t){for(const[n,i]of t.entries()){e.getChildByPath(n).matrix=i}}!function(e){e[e.Default=0]="Default",e[e.Translate=1]="Translate",e[e.Scale=2]="Scale"}(A||(A={}));class I{constructor(e=5,t=.5235987755982988,n=0){this.radius=0,this.phi=0,this.theta=0,this.radius=e,this.phi=t,this.theta=n}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi,e.phi,this.theta=e.theta,this}makeSafe(e=Math.EPSILON){return this.phi=I.makeSafePhi(this.phi,e),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Math.clamp(t/this.radius,-1,1))),this}toCoords(e=new t.Vec3){const n=Math.sin(this.phi)*this.radius;return e.x=n*Math.sin(this.theta),e.y=Math.cos(this.phi)*this.radius,e.z=n*Math.cos(this.theta),e}toQuat(e=new t.Quat,n=Math.HALF_PI){const i=.5*(this.phi-n),o=.5*this.theta,a=Math.sin(i),r=Math.cos(i),s=Math.sin(o),c=Math.cos(o);return e.x=a*c,e.y=r*s,e.z=-a*s,e.w=r*c,e}clone(){return new I(this.radius,this.phi,this.theta)}static makeSafePhi(e,t=Math.EPSILON){return Math.max(t,Math.min(Math.PI-t,e))}}class x{constructor(){this.eventMap=new Map}on(e,t,n){this._on(e,t,n,!1)}once(e,t,n){this._on(e,t,n,!0)}_on(e,t,n,i){let o=this.eventMap.get(e);null==o&&(o=[],this.eventMap.set(e,o)),o.push({callback:t,target:n,once:i})}off(e,t,n){const i=this.eventMap.get(e);if(null==i)return!1;const o=i.findIndex((e=>e.callback==t&&e.target==n));if(-1==o)return!1;i.removeAt(o)}offType(e){const t=this.eventMap.get(e);null!=t&&(t.length=0)}offAll(){this.eventMap.clear()}dispatch(e,...t){const n=this.eventMap.get(e);if(null!=n)for(let e=n.length-1;e>=0;e--){const i=n[e];i.callback.call(i.target,...t),i.once&&n.splice(e,1)}}hasListener(e,t,n){const i=this.eventMap.get(e);if(null==i)return!1;return-1!=i.findIndex((e=>e.callback==t&&e.target==n))}}class T{get designWidth(){return this._designWidth}get designHeight(){return this._designHeight}constructor(e,t){this.eventSystem=e,this.scene=t,this._designWidth=1334,this._designHeight=750}initialize(){const e=new t.Node("Canvas"),n=e.addComponent(t.Canvas);e.layer=t.Layers.Enum.UI_2D,u(e,t.Widget,{isAlignTop:!0,isAlignBottom:!0,isAlignLeft:!0,isAlignRight:!0,left:0,right:0,top:0,bottom:0}),this.scene.addChild(e);const i=new t.Node("UICamera"),o=n.cameraComponent=i.addComponent(t.Camera);o.priority=3,o.visibility=t.Layers.BitMask.UI_2D,o.clearFlags=t.Camera.ClearFlag.DEPTH_ONLY,o.clearColor=t.Color.BLACK,o.projection=t.Camera.ProjectionType.ORTHO,o.far=2e3,i.setPosition(0,0,1e3),e.addChild(i),t.screen.on("window-resize",this.onCanvasResize,this),this.onCanvasResize()}finalize(){t.screen.off("window-resize",this.onCanvasResize,this)}onCanvasResize(){const e=t.screen.windowSize;this.resetDesignResolutionSize(e.width,e.height)}swapDesignSize(){const e=this.designWidth;this._designWidth=this.designHeight,this._designHeight=e}resetDesignResolutionSize(e,n){(e>n&&this.designWidth<this.designHeight||e<n&&this.designWidth>this.designHeight)&&this.swapDesignSize();const i=(this.designWidth/e+this.designHeight/n)/2,o=e*i,a=n*i;t.view.setDesignResolutionSize(o,a,t.ResolutionPolicy.SHOW_ALL)}}class S{constructor(e,n,i,o){this.eventSystem=e,this.scene=n,this.camera=i,this.meshRenderer=o,this.spherical=new I;const a=4*o.model.modelBounds.halfExtents.length();i.near=a/100,i.far=100*a,this.minDistance=a/100,this.maxDistance=10*a,this.targetNode=new t.Node("TargetNode"),this.camera.node.parent.addChild(this.targetNode),this.camera.node.setParent(this.targetNode),this.reset()}initialize(){const e=t.director.getScene().getChildByName("Canvas");e.on(t.Node.EventType.MOUSE_MOVE,this.onMouseMove,this),e.on(t.Node.EventType.MOUSE_WHEEL,this.onWheel,this),this.eventSystem.on(O.OperationEvent,this.onOperateModeChanged,this),this.createOperationUI()}finalize(){const e=t.director.getScene().getChildByName("Canvas");e.off(t.Node.EventType.MOUSE_MOVE,this.onMouseMove,this),e.off(t.Node.EventType.MOUSE_WHEEL,this.onWheel,this),this.eventSystem.off(O.OperationEvent,this.onOperateModeChanged,this)}createOperationUI(){const e=this.scene.getChildByName("Canvas"),n=v(e,"OperationNode",{width:50,height:182}),i=u(n,t.Widget,{isAlignLeft:!0,isAlignBottom:!0,left:12,bottom:92}),o=v(n,"background");p(o,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABrSURBVHgB7ZbBDYAwDAMNEzACKzAJoxYmKBvAJnSDEKN2g/iXkyz5lXvGgGNmq6d6Xouh8CZvT73cngWxNM9GweFlh4aLAoOOphZghpgUpCAFKUhBlKBBCAUPdJzyp/+3PluKxcDpU8ds+QD7lMULwzSDJAAAAABJRU5ErkJggg==",{insetTop:10,insetBottom:10,insetLeft:10,insetRight:10},{color:new t.Color("00000066"),type:t.Sprite.Type.SLICED}),u(o,t.Widget,{isAlignLeft:!0,isAlignRight:!0,isAlignTop:!0,isAlignBottom:!0,left:0,right:0,top:0,bottom:0});const a=v(n,"LayoutContainer",{width:30});let r;u(a,t.Layout,{type:t.Layout.Type.VERTICAL,alignVertical:!0,spacingY:14,resizeMode:t.Layout.ResizeMode.CONTAINER}),this.eventSystem.on(O.ModuleEnableEvent,((e,t)=>{switch(e){case"operation":n.active=t;break;case"animation":i.bottom=t?92:12}}));const s=new t.Color("FFFFFF"),c=new t.Color("F3AD02"),l=r=S.createSprite(a,"rotation",c,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMAYKDfQCAQ73CQgFAwz1+/gVAnQQAAAOhJREFUOMutU1sWhSAIFCUfad32v9oLmaKH/Gt+OMI0yITmY2wIGf2qWpK7bji7GQ1vrwGagoHSwUaAaB2r5Ll+cg7bCZhyjvVMiTQmdkrgcHn6Yqc4M4KMY3tdkOimXYD6c4AOnoFUiwgABZAp+YhyLUcCmmACpxn+6QYUgcCCjzC1qlrxIcAYY5s0S0HHVcGHi5HXLdjK1mJ7u2SV8G3MoMeMFJy4itqHQ7wur1Yj2yBeJ6Pws7JuQf1OT8JNoMrNjHQYQZvAQec7tmZGdkypS3vvL6o3M689W6Qp7eGkYhbwmAE38y3+Ag4P1RAPgmQAAAAASUVORK5CYII=",(e=>{r!=l&&(r.color=s,r=l,r.color=c,this.onOperateModeChanged(A.Default))})),d=S.createSprite(a,"move",s,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAD////////////////////////////////////////PIev5AAAACnRSTlMAEGDQ34AgcKCfzLIS3QAAAJlJREFUKM9jIBowCqAJCBuiKbBaLICqYNUqQ1QFq1ZBlCAUoCrRWhK11Gs5kgCrm9ailACECQUMAlqLGBmYBGAmLAVqWsTAEGUIs2KJAEiA0WuxANQKN4iKlFWGUDcEKSl1rVRSUgW6BawACRhiCGBoQTcUw1pMh0GUKECczi6A7jkEqAJ5fxGeAEIEIWYgY0YDIqIwo5JYAAAsUkTxaveYMwAAAABJRU5ErkJggg==",(e=>{r!=d&&(r.color=s,r=d,r.color=c,this.onOperateModeChanged(A.Translate))})),m=S.createSprite(a,"zoom",s,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAOVBMVEUAAAD///////////////////////////////////////////////////////////////////////8KOjVvAAAAEnRSTlMAoN9gEEAggO9/cJAwv1DQr4/DWaH9AAAA5UlEQVQ4y62SSRaEIAxEgTA14NC5/2E78SlJi7qyVkA+oeoR865igNBuq6Fm3LTCVdl/UeTi2NzRea4AkCZGPud6pmvh2Fgh1H3rZV+ICBqwVDdaQA3Vhdi3YHewIqa/BtBXe6iMWQCHTtB9VZWLJg4ECIjF6PX2vuU0JH6DVsoybLe7+FQB8y0gHurgoUlOjjQJIO/OPeaE2M4A2fVGxZhOAOwWpEUZfi/qYUImdF0syv9+Ys+dx5FJPGg2eONb4ZEaidmhUk0jEdOB5JVCC6G9FvqoCpz/mhhsLeaZWLx5ljev6AelqQ+hmP4VtgAAAABJRU5ErkJggg==",(e=>{r!=m&&(r.color=s,r=m,r.color=c,this.onOperateModeChanged(A.Scale))}));S.createSprite(a,"reset",s,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAM1BMVEUAAAD///////////////////////////////////////////////////////////////+3leKCAAAAEHRSTlMA36BAYBDvIHCQUDCAz79/geN8gwAAANhJREFUOMutk9sSwiAQQ3e5X6zm/7/WosZStr6ZJ2DOhJBZ5M/KPjQf5Yd6VbykLotVdJhkEZ8AJFdCKE6HS1uAsp95bsJAwkJsdd7ddsJP4bsIsx9EOo7cXYwq4L4Gw85IgU4D4MLCA/VgUSyRoJ+KACaiaJzptetmgMJoDdcWgWVxMSsmDDVewYjnKnlFZiXWIvKZSa4iQtnqZZPbYdzJrk3mqZJqibs7JXosIXfjPNstRN1sa9Dw5dVW03Qg76F9za95Vz6P/ajIIvw4tcsPRd+Cz/JfPQEx0Au8uJZWXAAAAABJRU5ErkJggg==",(e=>{r.color=s,r=l,r.color=c,this.onOperateModeChanged(null)}))}static createSprite(e,n,i,o,a,r){const s=v(e,n,{width:30,height:30}),c=p(s,o,void 0,{sizeMode:t.Sprite.SizeMode.CUSTOM,color:i});return u(s,t.Button,{transition:t.Button.Transition.SCALE}),s.on(t.Button.EventType.CLICK,a,r),c}onOperateModeChanged(e){if(null==e)return this.reset();this.operateMode=e}updateSphericalToCamera(){this.camera.node.position=this.spherical.toCoords(this.camera.node.position),this.camera.node.rotation=this.spherical.toQuat(this.camera.node.rotation)}onWheel(e){this.scale(.01*e.getScrollY()*this.minDistance),this.updateSphericalToCamera()}onMouseMove(e){const t=e.getButton();switch(this.operateMode){case A.Default:switch(t){case 0:this.rotate(e.getDelta());break;case 1:this.translate(e.getDelta())}break;case A.Translate:0==t&&this.translate(e.getDelta());break;case A.Scale:0==t&&this.scale(.01*-e.getDeltaY())}this.updateSphericalToCamera()}reset(){const e=this.meshRenderer.model.worldBounds,t=4*e.halfExtents.length();this.targetNode.position=e.center,this.camera.node.position=o.set(t/2,t/5,t/2),this.spherical.setFromVector3(this.camera.node.position),this.camera.node.rotation=this.spherical.toQuat(this.camera.node.rotation),this.operateMode=A.Default}rotate(e){const t=.02*-e.x,n=.02*e.y;this.spherical.theta+=t,this.spherical.phi=I.makeSafePhi(this.spherical.phi+n,.2)}translate(e){const t=o.set(.01*e.x,.01*e.y,0);t.transformQuat(this.camera.node.rotation),this.targetNode.position=this.targetNode.position.subtract(t)}scale(e){this.spherical.radius=Math.clamp(this.spherical.radius-e,this.minDistance,this.maxDistance)}}class y{get enabled(){return this._enabled}set enabled(e){this._enabled!=e&&(this._enabled=e,this.labelNode.active=e)}constructor(e,t,n){this.eventSystem=e,this.scene=t,this.meshRenderer=n,this._enabled=!0}getMeshInfo(){const e=this.meshRenderer.mesh,t=e.renderingSubMeshes.length;let n=0,i=0,o=0;for(let o=0;o<t;o++){const t=e.renderingSubMeshes[o];for(let e=0;e<t.vertexBuffers.length;e++){n+=t.vertexBuffers[e].count;const o=t.indexBuffer;null!=o&&(i+=o.count/3)}}null!=this.meshRenderer.skeleton&&(o=this.meshRenderer.skeleton.joints.length);let a=`Vertex: ${n}\nTriangle: ${i}`;return o>0&&(a+=`\nJoint: ${o}`),a}initialize(){const e=this.scene.getChildByName("Canvas");this.labelNode=v(e,"LabelNode",{anchorX:0,anchorY:1}),u(this.labelNode,t.Label,{fontSize:25,lineHeight:0,enableOutline:!0,horizontalAlign:t.Label.HorizontalAlign.LEFT,string:this.getMeshInfo()}),u(this.labelNode,t.Widget,{isAlignTop:!0,isAlignLeft:!0,left:0,top:0}),this.eventSystem.on(O.ModuleEnableEvent,this.onModuleEnabled,this)}onModuleEnabled(e,t){"statistic"==e&&(this.enabled=t)}finalize(){this.eventSystem.off(O.ModuleEnableEvent,this.onModuleEnabled,this)}}class N{get hsvParams(){return this._hsvParams}get shaderParams(){return this._shaderParams}constructor(e,t){this.eventSystem=e,this.meshRenderer=t,this.defaultMaterial=t.sharedMaterial,this.initiMaterial(t.sharedMaterial,0)}setMaterial(e,t){null==e?(this.meshRenderer.setSharedMaterial(this.defaultMaterial,0),e=this.defaultMaterial):this.meshRenderer.setSharedMaterial(e,0),this.initiMaterial(e,t)}initiMaterial(e,t){const n=e.passes[t];null!=n&&(this._hsvParams=void 0,this._shaderParams=void 0,e.effectName.endsWith("hsv-standard")?(this._hsvParams=N.getHsvParams(n),this._shaderParams=N.getStandardParams(n)):e.effectName.endsWith("hsv-unlit")?(this._hsvParams=N.getHsvParams(n),this._shaderParams=N.getUnlitParams(n)):"builtin-standard"==e.effectName?this._shaderParams=N.getStandardParams(n):"builtin-unlit"==e.effectName&&(this._shaderParams=N.getUnlitParams(n)),this.id=h(e.uuid))}getMaterialData(){return null==this.shaderParams?void 0:{id:this.id,hsv:this.hsvParams,shaderParams:this.shaderParams}}static getHsvParams(e){let t=[];for(let n=0;n<m.length;n++)if(e.defines[m[n]]){t[n]=[0,0,0];for(let i=0;i<l.length;i++){const o=`${l[i]}${d[n]}`;t[n][i]=_(e.getUniform(e.getHandle(o),0))}}return t}static getStandardParams(e){return{mainColor:_(e.getUniform(e.getHandle("mainColor"),new t.Vec4)),occlusion:_(e.getUniform(e.getHandle("occlusion"),0)),roughness:_(e.getUniform(e.getHandle("roughness"),0)),metallic:_(e.getUniform(e.getHandle("metallic"),0)),specularIntensity:_(e.getUniform(e.getHandle("specularIntensity"),0)),emissive:_(e.getUniform(e.getHandle("emissive"),new t.Vec4))}}static getUnlitParams(e){return{mainColor:_(e.getUniform(e.getHandle("mainColor"),new t.Vec4))}}initialize(){this.eventSystem.on(O.HsvEvent,this.onHsvChanged,this),this.eventSystem.on(O.ShaderParamEvent,this.onShaderParamsChanged,this)}finalize(){this.eventSystem.off(O.HsvEvent,this.onHsvChanged,this),this.eventSystem.off(O.ShaderParamEvent,this.onShaderParamsChanged,this)}onHsvChanged(e,t,n){const i=N.getPropertyName(e,t);this.meshRenderer.material.setProperty(i,n)}onShaderParamsChanged(e,n){if(Array.isArray(n))switch(n.length){case 2:n=new t.Vec2(n[0],n[1]);break;case 3:n=new t.Vec3(n[0],n[1],n[2]);break;case 4:n=new t.Vec4(n[0],n[1],n[2],n[3])}this.meshRenderer.material.setProperty(e,n)}static getPropertyName(e,t){return`${l[t]}${d[e]}`}}class P{constructor(e,t){this.eventSystem=e,this.node=t}initialize(){this.eventSystem.on(O.TransformEvent,this.onTransformChanged,this)}onTransformChanged(e,t,n){const i=this.node[e];i[t]=n,this.node[e]=i}finalize(){this.eventSystem.off(O.TransformEvent,this.onTransformChanged,this)}}class M{get referModelNode(){return this._referModelNode}get enabled(){return this._enabled}set enabled(e){if(this._enabled==e)return;this._enabled=e,this.separateNode.active=e,this.referCameraNode.active=e,this.referModelNode.active=e;this.cameraNode.getComponent(t.Camera).rect=e?new t.Rect(.5,0,.5,1):new t.Rect(0,0,1,1)}constructor(e,t,n,i,o){this.eventSystem=e,this.scene=t,this.cameraNode=n,this.modelNode=i,this.poseTransform=o,this._enabled=!0}initialize(){var e;const i=t.director.getScene().getChildByName("Canvas"),o=this.separateNode=new t.Node("SeparateNode");o.layer=t.Layers.Enum.UI_2D;const a=o.addComponent(t.Widget);a.isAlignTop=a.isAlignBottom=a.isAlignHorizontalCenter=!0;const r=o.addComponent(t.Sprite);r.sizeMode=t.Sprite.SizeMode.CUSTOM,r.color=t.Color.WHITE,g(r,n);o.getComponent("cc.UITransform").width=2,i.addChild(o);const s=this.referCameraNode=(0,t.instantiate)(this.cameraNode);this.cameraNode.addChild(s),s.position=t.Vec3.ZERO,s.rotation=t.Quat.IDENTITY,s.scale=t.Vec3.ONE;const c=s.getComponent(t.Camera);c.visibility=t.Layers.BitMask.DEFAULT|t.Layers.BitMask.IGNORE_RAYCAST,c.rect=new t.Rect(0,0,.5,1);const l=this._referModelNode=(0,t.instantiate)(this.modelNode);l.setLayerRecursive(t.Layers.Enum.IGNORE_RAYCAST);const d=null!==(e=this.referModelNode.getComponent("cc.MeshRenderer"))&&void 0!==e?e:this.referModelNode.getComponentInChildren("cc.MeshRenderer");this.defaultMaterial=d.sharedMaterial,this.scene.addChild(l);const m=l.getOrAddComponent("cc.SkeletalAnimation");for(let e=0;e<m.clips.length;e++){let n=m.clips[e];m.getState(n.name).wrapMode=t.AnimationClip.WrapMode.Loop}this.eventSystem.on(O.ModuleEnableEvent,this.onModuleEnabled,this)}finalize(){this.eventSystem.off(O.ModuleEnableEvent,this.onModuleEnabled,this)}setMaterial(e,t){var n;const i=null!==(n=this.referModelNode.getComponent("cc.MeshRenderer"))&&void 0!==n?n:this.referModelNode.getComponentInChildren("cc.MeshRenderer");console.assert(null!=i),i.material=null==e?this.defaultMaterial:e}setAnimation(e){const n=this.referModelNode.getOrAddComponent("cc.SkeletalAnimation");if(n.useBakedAnimation=!1,null==e)n.stop(),E(this.referModelNode,this.poseTransform);else{n.addClip(e,e.name).wrapMode=t.AnimationClip.WrapMode.Loop,n.play(e.name)}}onModuleEnabled(e,t){"reference"==e&&(this.enabled=t)}}class R{get duration(){return this.animationState.clip.duration}get frameRate(){return this.animationState.frameRate}get totalFrame(){return this.duration*this.frameRate}get slideBarWidth(){return Math.trunc(this.totalFrame)*r}constructor(e,t,n,i){this.eventSystem=e,this.scene=t,this.modelNode=n,this.poseTransform=i,this.eventNodes=[]}createControllerUI(){const e=v(t.director.getScene().getChildByName("Canvas"),"AnimationPanel",{height:a});e.addComponent("cc.BlockInputEvents"),u(e,t.Widget,{isAlignRight:!0,isAlignLeft:!0,isAlignBottom:!0,left:0,right:0,bottom:0}),p(e,n,void 0,{color:new t.Color("FFFFFF")}),this.eventSystem.on(O.ModuleEnableEvent,((t,n)=>{"animation"==t&&(e.active=n)}));const i=Math.trunc(32),o=v(e,"PlayButton",{width:a,height:a});u(o,t.Widget,{isAlignLeft:!0,isAlignBottom:!0,left:0});const s=v(o,"PlayIconNode",{width:i,height:i});p(s,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAaVBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8G612AAAAInRSTlMAPPjZv0z88/DjzbATC+uikX9cJRsGcjC5LtG1nGpjNjIpX57DmAAAAOlJREFUWMPt1UduQkEUBdEf4ZvgHLBN7P0vEgQSJTG5ohgw4SygRrdfVw8X6m6Y9JW3acrBcq4Di3LU/trAUE6alQyUs+nMBfBUuwBGbzKA7tMF8NzLAF6/XACTDxfA+F0G8DJ3AbQ/LoDmWwdYtg2wbBtg2TrAsm2AZesAy7YBlu0DLNsHWLYPcLN9oAw7F8D01sBw98D/jYFm6wO8bB9YzPyQ8nUrcPdVvgPIlwh5CyCvEeQ9hLzIkH8CwnYz+S8ibDcL283CdrOw3SxsNwvbzcJ2s7DdbMx2nY7tOvWI7Tr9X2nX1cOV9q1hrAMzTtf9AAAAAElFTkSuQmCC",void 0,{color:t.Color.GRAY});const c=v(o,"PauseIconNode",{width:i,height:i});p(c,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAAAG1BMVEUAAAD////////////////////////////////rTT7CAAAACHRSTlMA8KwcrqonJfDNE8wAAABTSURBVEjHYxg8gFlRJAEfn8Gwo0MYH59Bo6OjFR+fQaKjoxEfn6EDCND5owpGFYwqGFUwqmBUARCQVqF4dHQ04eMzJHZ0iOPjMzAHChVg8AcNAABE7OJnhfpS+AAAAABJRU5ErkJggg==",void 0,{color:t.Color.GRAY}),c.active=!1;const l=t.Color.GRAY,d=this.playToggle=u(o,t.Toggle,{interactable:!0,target:c,transition:t.Button.Transition.COLOR,normalColor:t.Color.GRAY,hoverColor:t.Color.BLACK,pressedColor:t.Color.BLACK,disabledColor:l,isChecked:!1});o.on(t.Toggle.EventType.TOGGLE,(()=>{s.active=!d.isChecked,c.active=d.isChecked,d.target=d.isChecked?c:s;const e=this.modelNode.getComponent("cc.SkeletalAnimation");d.isChecked?e.resume():e.pause(),e.unscheduleAllCallbacks(),d.isChecked&&e.schedule(this.onUpdateFrame.bind(this))}));u(p(v(o,"LineNode",{width:2}),n,void 0,{color:t.Color.WHITE}),t.Widget,{isAlignTop:!0,isAlignBottom:!0,isAlignRight:!0,top:0,bottom:0,right:0});const m=v(e,"FrameNode",{width:100});this.frameDisplayLabel=u(m,t.Label,{string:"0 / 0",fontSize:24,overflow:t.Label.Overflow.SHRINK,color:l}),u(m,t.Widget,{isAlignTop:!0,isAlignBottom:!0,isAlignLeft:!0,left:a,top:0,bottom:0});const A=v(e,"TrackNode",{height:a});u(A,t.Widget,{isAlignBottom:!0,isAlignRight:!0,isAlignLeft:!0,left:180,right:0,bottom:0}),u(A,t.Mask);const _=v(A,"TimeAxisNode",{height:59,width:1920,anchorX:0});p(_,"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wgARCAA8AKADAREAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAgABBwj/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAD1SREREREREREREQBkRERERERERERAGYaYaYaYaYaYaYaYaYaAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAYBgGAZzo0w0w0w0w0w0w0w0w0w0//8QAJRAAAQMCBQUBAQAAAAAAAAAAAwECEDNyAAQFktIGERIWUzFA/9oACAEBAAE/AP5AUB2p/ICgO1IG7zY1353RFgbvNjXfndEWBu82Nd+d0RYG7zY1353RFgbvNjXfndEWBu82Nd+d0RYG7zY1353RFgbvNjXfndEWBu82Nd+d0RYBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UgFAdqQCgO1IBQHakAoDtSAUB2pAKA7UhnWuotYjUDlNjuWPd9S+GT2O5YZ1rqLWI1A5TY7lj3fUvhk9juWGda6i1iNQOU2O5Y931L4ZPY7lhnWuotYjUDlNjuWPd9S+GT2O5YZ1rqLWI1A5TY7lj3fUvhk9juWGda6i1iNQOU2O5Y931L4ZPY7lhnWuotYjUDlNjuWPd9S+GT2O5YZ1rqLWI1A5TY7lj3fUvhk9juWGda6i1iNQOU2O5Y931L4ZPY7lhnWuotYjUDlNjuWPd9S+GT2O5Y//8QAFBEBAAAAAAAAAAAAAAAAAAAAcP/aAAgBAgEBPwAg/8QAFBEBAAAAAAAAAAAAAAAAAAAAcP/aAAgBAwEBPwAg/9k=",void 0,{type:t.Sprite.Type.TILED,color:new t.Color("FFFFFF")});const h=u(_,t.Widget,{isAlignBottom:!0,isAlignLeft:!0,left:r,bottom:0});_.on(t.Node.EventType.TOUCH_MOVE,(e=>{const t=A.getComponent("cc.UITransform").contentSize;h.left=Math.minmax(-1920+t.width-r,r,h.left+e.getDeltaX())}));for(let e=0;e<=120;e++){if(e%10!=0)continue;const n=v(_,`TimeLabel${e}`);u(n,t.Label,{fontSize:20,color:l,string:`${e}`}),n.setPosition(e*r,30)}const g=v(_,"TrackSlideNode",{height:45,width:0});u(g,t.Widget,{isAlignBottom:!0,bottom:0});const C=v(g,"TrackSlideBackgroundNode");p(C,n,void 0,{type:t.Sprite.Type.SIMPLE,color:new t.Color("#F3AD024D")}),u(C,t.Widget,{isAlignTop:!0,isAlignBottom:!0,isAlignLeft:!0,isAlignRight:!0,top:0,bottom:0,left:0,right:0,alignMode:t.Widget.AlignMode.ALWAYS});const f=v(g,"TrackHandleNode",{width:32,height:75});f.positionY=10;const E=p(f,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAABKBAMAAAAoO0v7AAAAFVBMVEUAAADzqwLzrQH0rgH0rQL0rQHzrQLe/k5bAAAABnRSTlMAgO9f398mcJl1AAAAMklEQVQ4y2MwSkMBzgxuqAJJDGloYFSAkIAaKj+VwRRVQJkBChgFoIxRgVGBUQGaCgAAB/GOhY0o1ssAAAAASUVORK5CYII=",void 0,{type:t.Sprite.Type.SIMPLE,color:t.Color.WHITE}),I=v(f,"TrackHandleLabelNode");this.frameLabel=u(I,t.Label,{fontSize:20,color:t.Color.WHITE,string:"0"}),I.positionY=27.5,this.frameSlider=function(e,n,i){const o=u(e,t.Slider,i);return o.node.on("slide",n),o}(g,(()=>{const e=this.frameSlider.progress=Math.round(this.frameSlider.progress*this.totalFrame)/this.totalFrame;this.setFrameLabel(e),this.animationState.setTime(e*this.duration),this.animationState.sample(),d.isChecked&&(d.isChecked=!1)}),{handle:E,progress:0}),this.frameSlider.node.positionX=0,this.enabledMask=v(e,"EnabledMaskNode"),u(this.enabledMask,t.Widget,{isAlignTop:!0,isAlignBottom:!0,isAlignLeft:!0,isAlignRight:!0,top:0,bottom:0,left:0,right:0}),u(this.enabledMask,"cc.BlockInputEvents"),p(this.enabledMask,n,void 0,{color:new t.Color("CCCCCC44")})}onUpdateFrame(){const e=this.animationState.ratio;this.setFrameLabel(e),this.frameSlider.progress=e}updateEvents(){this.removeAnimaitonEvents();const e=this.animationState.clip.events;for(let t=0;t<e.length;t++)this.eventNodes[t]=this.createEvent(t,e[t].frame,e[t].func)}removeAnimaitonEvents(){for(const e of this.eventNodes)e.destroy();this.eventNodes.length=0}createEvent(e,n,a){let r;switch(a){case"onAnimationDamageEvent":const e=v(null,"Damage",{width:24,height:24});r=p(e,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAANlBMVEUAAADzrQHzrwLzrQLzrQL////868D0shL1uCL+9d/979D51oD625D++u/75q/40XD2wUH1vDGMFR1XAAAABHRSTlMAYH9/k1mkLgAAAHdJREFUKM9lz1kOgCAMRVEHWkUc979ZNfTltWm/yD2UhMHNPPEceimU2CmxU3KnsFNCX3Wl+Pu7VIp/R8ULegepC6V3A9kovQOCjAZ6BBkHE72xg26yFG1V6v4JOnau5/9kE7UOwbSTPQo7hT0LOwU9CXoW9Cy+v16oBWgT50IdAAAAAElFTkSuQmCC",void 0);break;case"onAnimationEffectEvent":const t=v(null,"Effect",{width:24,height:24});r=p(t,"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAPFBMVEUAAADzrgL0rQPyrQDzrQL////0shL98ND2wUH868D+9d/74KD625D51oD3x1H75bD40XH1uCL1tyL4zGEe5gSWAAAABHRSTlMAf2BgxHFDCAAAAI5JREFUKM91zosKgzAMhWG75dJOq9O9/7suJrjjDAYK5f8g7XCaUnD/60TlpofkDskdgg7JfV7t7IK+tbHWxl2UP5BCJOwzkXIlE+x5OYxE1k2wf2GfN34QvTJf5UnY5K/EPAYXaSFd0ENs+v72JL8OabySqhwdIrMdXY4OCd2iZ0GHoCfxngQ9S/Qs5/4F2vkF1SIK0RcAAAAASUVORK5CYII=",void 0);break;default:return}this.frameSlider.node.addChild(r.node);const c=this.slideBarWidth,l=.5*c,d=this.totalFrame,m=1/d*c;r.node.positionX=n/this.duration*c-l;const A=this.frameSlider.node.getComponent("cc.UITransform");return r.node.on(t.Node.EventType.TOUCH_START,(e=>{e.propagationStopped=!0,r.node.scaleXYZ=1.5})),r.node.on(t.Node.EventType.TOUCH_END,(e=>{e.propagationStopped=!0,r.node.scaleXYZ=1})),r.node.on(t.Node.EventType.TOUCH_MOVE,(t=>{const n=t.getUILocation(i),c=A.convertToNodeSpaceAR(o.set(n.x,n.y),o),_=Math.minmax(0,d,Math.round((c.x+l)/m));r.node.positionX=_*m-l,this.eventSystem.dispatch(O.OnAnimationEventChangedEvent,e,_/d*this.duration,s[a]),t.propagationStopped=!0})),r.node}initialize(){this.createControllerUI(),this.eventSystem.on(O.AnimationSpeedChangedEvent,this.onSpeedChanged,this),this.eventSystem.on(O.AnimationEventChangedEvent,this.onAnimationEventChangedEvent,this)}finalize(){this.eventSystem.off(O.AnimationSpeedChangedEvent,this.onSpeedChanged,this),this.eventSystem.off(O.AnimationEventChangedEvent,this.onAnimationEventChangedEvent,this)}getAnimationData(){return null==this.animationState?void 0:{id:this.animationState.clip.uuid,speed:this.animationState.clip.speed,duration:this.animationState.clip.duration,frameRate:this.animationState.frameRate,events:function(e){const t=[];for(const n of e)t.push({time:n.frame,type:s[n.func]});return t}(this.animationState.clip.events)}}onAnimationEventChangedEvent(e,t){if(null==this.eventNodes[e])return;const n=this.slideBarWidth,i=Math.round(t/this.duration*this.totalFrame);this.eventNodes[e].positionX=i/this.totalFrame*n-.5*n}setAnimation(e){const n=this.modelNode.getOrAddComponent("cc.SkeletalAnimation");if(n.useBakedAnimation=!1,null!=e){n.addClip(e,e.name).wrapMode=t.AnimationClip.WrapMode.Loop,this.animationState=n.getState(e.name),n.play(e.name),this.playToggle.isChecked=!0,this.enabledMask.active=!1,this.onUpdateFrame(),this.updateTimeAxisSize(),this.updateEvents()}else this.playToggle.isChecked=!1,this.enabledMask.active=!0,this.removeAnimaitonEvents(),null!=this.animationState&&this.setFrameLabel(0),this.frameSlider.progress=0,C(this.frameSlider.node,0),this.frameSlider.node.positionX=0,this.animationState=null,n.stop(),E(this.modelNode,this.poseTransform)}onSpeedChanged(e){this.animationState.speed=e}setFrameLabel(e){const t=this.totalFrame,n=Math.trunc(e*t);this.frameLabel.string=`${n}`,this.frameDisplayLabel.string=`${n} / ${Math.trunc(t)}`}updateTimeAxisSize(){const e=this.slideBarWidth;C(this.frameSlider.node,e),this.frameSlider.node.positionX=.5*e}}class O extends x{constructor(){super(...arguments),this.modules=[]}static translatePath(e){for(const t of Object.keys(globalThis.assetsKeyMap)){if(globalThis.assetsKeyMap[t]==e)return t}}static loadAsset(e,n){return new Promise(((i,o)=>t.assetManager.loadAny(O.translatePath(n),{__isNative__:!1,__requestType__:"url",type:e},((e,t)=>{if(e)return console.error(e,n),o(void 0);i(t)}))))}static create(n,i){const o=new O;return console.log(`%cModel Preview startup, version ${O.version}`,"color:#00AAEE"),globalThis.cocosSettings.launch.launchScene=null,globalThis.MV_PLAYABLE=!1,null!=i&&t.game.onPostProjectInitDelegate.add(i),t.game.onPostProjectInitDelegate.add((()=>new Promise((e=>{t.resources.load("presetConfig",((n,i)=>{if(n)return e();t.assetManager.loadBundle("presets",((t,n)=>e()))}))})))),t.game.onStart=()=>t.assetManager.loadBundle("presets",((i,a)=>e(this,void 0,void 0,(function*(){const e=yield O.loadAsset(t.Prefab,n);o.initialize(e)})))),o}initialize(e){var n;const i=new t.Scene("ModelPreview");i.globals.shadows.enabled=!0,i.globals.shadows.type=t.renderer.scene.ShadowType.Planar,i.globals.shadows.planeHeight=.001,i.globals.shadows.shadowColor=new t.Color("4C4C4CAA");const o=new t.Node("Main Camera"),a=o.addComponent(t.Camera);a.visibility=t.Layers.BitMask.DEFAULT|t.Layers.BitMask.UI_3D,a.clearColor=new t.Color("C2C2C2"),a.fovAxis=t.Camera.FOVAxis.VERTICAL,a.fov=60,a.rect=new t.Rect(.5,0,.5,1),i.addChild(o);const r=new t.Node("Directional Light"),s=r.addComponent("cc.DirectionalLight");s.color=new t.Color("FFFFFF"),s.shadowEnabled=!0,s.shadowPcf=t.renderer.scene.PCFType.SOFT_4X,r.rotation=t.Quat.fromEuler(r.rotation,-30,0,0),i.addChild(r),t.director.runSceneImmediate(i);const c=(0,t.instantiate)(e);c.setLayerRecursive(t.Layers.Enum.UI_3D);const l=null!==(n=c.getComponent("cc.MeshRenderer"))&&void 0!==n?n:c.getComponentInChildren("cc.MeshRenderer");l.shadowCastingMode=1;const d=new Map;f(e.data,d),i.addChild(c);const m=(0,t.deserialize)('[1,0,0,[["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,4]],[[0,"../gridEffect/gridEffect",[{"hash":1493810174,"name":"../gridEffect/gridEffect|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"Constant","stageFlags":16,"binding":0,"members":[{"name":"mainColor","type":16,"count":1},{"name":"lineColor","type":16,"count":1},{"name":"rimColor","type":16,"count":1},{"name":"gridParams","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constant","stageFlags":16,"binding":0,"members":[{"name":"mainColor","type":16,"count":1},{"name":"lineColor","type":16,"count":1},{"name":"rimColor","type":16,"count":1},{"name":"gridParams","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\\nprecision highp float;\\n#define QUATER_PI         0.78539816340\\n#define HALF_PI           1.57079632679\\n#define PI                3.14159265359\\n#define PI2               6.28318530718\\n#define PI4               12.5663706144\\n#define INV_QUATER_PI     1.27323954474\\n#define INV_HALF_PI       0.63661977237\\n#define INV_PI            0.31830988618\\n#define INV_PI2           0.15915494309\\n#define INV_PI4           0.07957747155\\n#define EPSILON           1e-6\\n#define EPSILON_LOWP      1e-4\\n#define LOG2              1.442695\\n#define EXP_VALUE         2.71828183\\n#define FP_MAX            65504.0\\n#define FP_SCALE          0.0009765625\\n#define FP_SCALE_INV      1024.0\\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\\n#define LIGHT_MAP_TYPE_DISABLED 0\\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\\n#define REFLECTION_PROBE_TYPE_NONE 0\\n#define REFLECTION_PROBE_TYPE_CUBE 1\\n#define REFLECTION_PROBE_TYPE_PLANAR 2\\n#define REFLECTION_PROBE_TYPE_BLEND 3\\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\\n#define LIGHT_TYPE_DIRECTIONAL 0.0\\n#define LIGHT_TYPE_SPHERE 1.0\\n#define LIGHT_TYPE_SPOT 2.0\\n#define LIGHT_TYPE_POINT 3.0\\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\\n#define TONE_MAPPING_ACES 0\\n#define TONE_MAPPING_LINEAR 1\\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\\n#endif\\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\\n#endif\\nstruct StandardVertInput {\\n  highp vec4 position;\\n  vec3 normal;\\n  vec4 tangent;\\n};\\nin vec3 a_position;\\nin vec3 a_normal;\\nin vec2 a_texCoord;\\nin vec4 a_tangent;\\n#if CC_USE_SKINNING\\n    in vec4 a_joints;\\n  in vec4 a_weights;\\n#endif\\n#if USE_INSTANCING\\n  #if CC_USE_BAKED_ANIMATION\\n    in highp vec4 a_jointAnimInfo;\\n  #endif\\n  in vec4 a_matWorld0;\\n  in vec4 a_matWorld1;\\n  in vec4 a_matWorld2;\\n  #if CC_USE_LIGHTMAP\\n    in vec4 a_lightingMapUVParam;\\n  #endif\\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\\n    #if CC_RECEIVE_SHADOW\\n    #endif\\n    in vec4 a_localShadowBiasAndProbeId;\\n  #endif\\n  #if CC_USE_REFLECTION_PROBE\\n    in vec4 a_reflectionProbeData;\\n  #endif\\n  #if CC_USE_LIGHT_PROBE\\n    in vec4 a_sh_linear_const_r;\\n    in vec4 a_sh_linear_const_g;\\n    in vec4 a_sh_linear_const_b;\\n  #endif\\n#endif\\n#if CC_USE_MORPH\\n    in float a_vertexId;\\n    int getVertexId() {\\n      return int(a_vertexId);\\n    }\\n#endif\\nhighp float decode32 (highp vec4 rgba) {\\n  rgba = rgba * 255.0;\\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\\n}\\n#if CC_USE_MORPH\\n  layout(std140) uniform CCMorph {\\n    vec4 cc_displacementWeights[15];\\n    vec4 cc_displacementTextureInfo;\\n  };\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    uniform sampler2D cc_PositionDisplacements;\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n    uniform sampler2D cc_NormalDisplacements;\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n    uniform sampler2D cc_TangentDisplacements;\\n  #endif\\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\\n    float pixelIndexF = float(pixelIndex);\\n    float x = mod(pixelIndexF, textureResolution.x);\\n    float y = floor(pixelIndexF / textureResolution.x);\\n    return vec2(x, y);\\n  }\\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\\n    return (vec2(location.x, location.y) + .5) / textureResolution;\\n  }\\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\\n        ivec2 texSize = textureSize(tex, 0);\\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\\n      }\\n  #else\\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\\n      int pixelIndex = elementIndex * 4;\\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\\n      return vec4(\\n        decode32(texture(tex, x)),\\n        decode32(texture(tex, y)),\\n        decode32(texture(tex, z)),\\n        1.0\\n      );\\n    }\\n  #endif\\n  float getDisplacementWeight(int index) {\\n    int quot = index / 4;\\n    int remainder = index - quot * 4;\\n    if (remainder == 0) {\\n      return cc_displacementWeights[quot].x;\\n    } else if (remainder == 1) {\\n      return cc_displacementWeights[quot].y;\\n    } else if (remainder == 2) {\\n      return cc_displacementWeights[quot].z;\\n    } else {\\n      return cc_displacementWeights[quot].w;\\n    }\\n  }\\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\\n  #if CC_MORPH_PRECOMPUTED\\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\\n  #else\\n    vec3 result = vec3(0, 0, 0);\\n    int nVertices = int(cc_displacementTextureInfo.z);\\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\\n    }\\n    return result;\\n  #endif\\n  }\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n  vec3 getPositionDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\\n  }\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n  vec3 getNormalDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\\n  }\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n  vec3 getTangentDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\\n  }\\n  #endif\\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\\n    int vertexId = getVertexId();\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\\n  #endif\\n  }\\n  void applyMorph (inout vec4 position) {\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\\n  #endif\\n  }\\n#endif\\n#if CC_USE_SKINNING\\n  #if CC_USE_BAKED_ANIMATION\\n    layout(std140) uniform CCSkinningTexture {\\n      highp vec4 cc_jointTextureInfo;\\n    };\\n    layout(std140) uniform CCSkinningAnimation {\\n      highp vec4 cc_jointAnimInfo;\\n    };\\n    uniform highp sampler2D cc_jointTexture;\\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\\n    {\\n      #if USE_INSTANCING\\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\\n      #else\\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\\n      #endif\\n      invSize = cc_jointTextureInfo.w;\\n      highp float tempY = floor(temp * invSize);\\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\\n      y = (tempY + 0.5) * invSize;\\n    }\\n  #else\\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\\n      uniform highp sampler2D cc_realtimeJoint;\\n    #else\\n      layout(std140) uniform CCSkinning {\\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\\n      };\\n    #endif\\n  #endif\\n  #if CC_USE_BAKED_ANIMATION\\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n      mat4 getJointMatrix (float i) {\\n        highp float x, y, invSize;\\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #else\\n      mat4 getJointMatrix (float i) {\\n        highp float x, y, invSize;\\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\\n        vec4 v1 = vec4(\\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\\n        );\\n        vec4 v2 = vec4(\\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\\n        );\\n        vec4 v3 = vec4(\\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\\n        );\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #endif\\n  #else\\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n        mat4 getJointMatrix (float i) {\\n          float x = i;\\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n        }\\n      #else\\n        mat4 getJointMatrix (float i) {\\n         float x = 4.0 * i;\\n          vec4 v1 = vec4(\\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\\n          );\\n          vec4 v2 = vec4(\\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\\n          );\\n          vec4 v3 = vec4(\\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\\n          );\\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n        }\\n      #endif\\n    #else\\n      mat4 getJointMatrix (float i) {\\n        int idx = int(i);\\n        vec4 v1 = cc_joints[idx * 3];\\n        vec4 v2 = cc_joints[idx * 3 + 1];\\n        vec4 v3 = cc_joints[idx * 3 + 2];\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #endif\\n  #endif\\n  mat4 skinMatrix () {\\n    vec4 joints = vec4(a_joints);\\n    return getJointMatrix(joints.x) * a_weights.x\\n         + getJointMatrix(joints.y) * a_weights.y\\n         + getJointMatrix(joints.z) * a_weights.z\\n         + getJointMatrix(joints.w) * a_weights.w;\\n  }\\n  void CCSkin (inout vec4 position) {\\n    mat4 m = skinMatrix();\\n    position = m * position;\\n  }\\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\\n    mat4 m = skinMatrix();\\n    position = m * position;\\n    normal = (m * vec4(normal, 0.0)).xyz;\\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\\n  }\\n#endif\\nvoid CCVertInput(inout StandardVertInput In)\\n{\\n    In.position = vec4(a_position, 1.0);\\n    In.normal = a_normal;\\n    In.tangent = a_tangent;\\n  #if CC_USE_MORPH\\n    applyMorph(In.position, In.normal, In.tangent);\\n  #endif\\n  #if CC_USE_SKINNING\\n    CCSkin(In.position, In.normal, In.tangent);\\n  #endif\\n}\\nlayout(std140) uniform CCGlobal {\\n  highp   vec4 cc_time;\\n  mediump vec4 cc_screenSize;\\n  mediump vec4 cc_nativeSize;\\n  mediump vec4 cc_probeInfo;\\n  mediump vec4 cc_debug_view_mode;\\n};\\nlayout(std140) uniform CCCamera {\\n  highp   mat4 cc_matView;\\n  highp   mat4 cc_matViewInv;\\n  highp   mat4 cc_matProj;\\n  highp   mat4 cc_matProjInv;\\n  highp   mat4 cc_matViewProj;\\n  highp   mat4 cc_matViewProjInv;\\n  highp   vec4 cc_cameraPos;\\n  mediump vec4 cc_surfaceTransform;\\n  mediump vec4 cc_screenScale;\\n  mediump vec4 cc_exposure;\\n  mediump vec4 cc_mainLitDir;\\n  mediump vec4 cc_mainLitColor;\\n  mediump vec4 cc_ambientSky;\\n  mediump vec4 cc_ambientGround;\\n  mediump vec4 cc_fogColor;\\n  mediump vec4 cc_fogBase;\\n  mediump vec4 cc_fogAdd;\\n  mediump vec4 cc_nearFar;\\n  mediump vec4 cc_viewPort;\\n};\\n#if !USE_INSTANCING\\n  layout(std140) uniform CCLocal {\\n    highp mat4 cc_matWorld;\\n    highp mat4 cc_matWorldIT;\\n    highp vec4 cc_lightingMapUVParam;\\n    highp vec4 cc_localShadowBias;\\n    highp vec4 cc_reflectionProbeData1;\\n    highp vec4 cc_reflectionProbeData2;\\n    highp vec4 cc_reflectionProbeBlendData1;\\n    highp vec4 cc_reflectionProbeBlendData2;\\n  };\\n#endif\\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\\n{\\n  #if USE_INSTANCING\\n    matWorld = mat4(\\n      vec4(a_matWorld0.xyz, 0.0),\\n      vec4(a_matWorld1.xyz, 0.0),\\n      vec4(a_matWorld2.xyz, 0.0),\\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\\n    );\\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\\n    vec3 scale2 = scale * scale;\\n    matWorldIT = mat4(\\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\\n      vec4(0.0, 0.0, 0.0, 1.0)\\n    );\\n  #else\\n    matWorld = cc_matWorld;\\n    matWorldIT = cc_matWorldIT;\\n  #endif\\n}\\nout vec2 v_uv;\\nout vec2 v_texCoord;\\nvec4 vert () {\\n  StandardVertInput In;\\n  CCVertInput(In);\\n  mat4 matWorld, matWorldIT;\\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\\n  v_uv = a_texCoord;\\n  v_texCoord = a_texCoord;\\n  return cc_matProj * (cc_matView * matWorld) * In.position;\\n}\\nvoid main() { gl_Position = vert(); }","frag":"\\n#extension GL_OES_standard_derivatives : enable\\nprecision highp float;\\nlayout(std140) uniform CCGlobal {\\n  highp   vec4 cc_time;\\n  mediump vec4 cc_screenSize;\\n  mediump vec4 cc_nativeSize;\\n  mediump vec4 cc_probeInfo;\\n  mediump vec4 cc_debug_view_mode;\\n};\\nlayout(std140) uniform CCCamera {\\n  highp   mat4 cc_matView;\\n  highp   mat4 cc_matViewInv;\\n  highp   mat4 cc_matProj;\\n  highp   mat4 cc_matProjInv;\\n  highp   mat4 cc_matViewProj;\\n  highp   mat4 cc_matViewProjInv;\\n  highp   vec4 cc_cameraPos;\\n  mediump vec4 cc_surfaceTransform;\\n  mediump vec4 cc_screenScale;\\n  mediump vec4 cc_exposure;\\n  mediump vec4 cc_mainLitDir;\\n  mediump vec4 cc_mainLitColor;\\n  mediump vec4 cc_ambientSky;\\n  mediump vec4 cc_ambientGround;\\n  mediump vec4 cc_fogColor;\\n  mediump vec4 cc_fogBase;\\n  mediump vec4 cc_fogAdd;\\n  mediump vec4 cc_nearFar;\\n  mediump vec4 cc_viewPort;\\n};\\nvec4 CCFragOutput (vec4 color) {\\n  return color;\\n}\\nin vec2 v_uv;\\nin vec2 v_texCoord;\\nlayout(std140) uniform Constant {\\n  vec4 mainColor;\\n  vec4 lineColor;\\n  vec4 rimColor;\\n  vec4 gridParams;\\n};\\nfloat grid(float width, vec2 step, vec2 pos){\\n    vec2 coord = pos / step;\\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord * width);\\n    float line = min(grid.x, grid.y);\\n    return 1. - min(line, 1.0);\\n}\\nvec4 frag () {\\n  float scale = gridParams.w;\\n  float v = grid(1.0, vec2(0.1 * scale), v_uv) * gridParams.x\\n          + grid(1.0, vec2(5.0 * scale), v_uv * 10.0) * gridParams.y;\\n  vec3 c = v * lineColor.rgb;\\n  c = mix(mainColor.rgb, c, v);\\n  float dist = length(v_texCoord - vec2(0.5, 0.5)) * 2.;\\n  c = mix(rimColor.rgb, c, smoothstep(rimColor.a, 0.0, dist));\\n  return CCFragOutput(vec4(c, mainColor.a));\\n}\\nlayout(location = 0) out vec4 cc_FragColor;\\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\\nprecision highp float;\\n#define QUATER_PI         0.78539816340\\n#define HALF_PI           1.57079632679\\n#define PI                3.14159265359\\n#define PI2               6.28318530718\\n#define PI4               12.5663706144\\n#define INV_QUATER_PI     1.27323954474\\n#define INV_HALF_PI       0.63661977237\\n#define INV_PI            0.31830988618\\n#define INV_PI2           0.15915494309\\n#define INV_PI4           0.07957747155\\n#define EPSILON           1e-6\\n#define EPSILON_LOWP      1e-4\\n#define LOG2              1.442695\\n#define EXP_VALUE         2.71828183\\n#define FP_MAX            65504.0\\n#define FP_SCALE          0.0009765625\\n#define FP_SCALE_INV      1024.0\\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\\n#define LIGHT_MAP_TYPE_DISABLED 0\\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\\n#define REFLECTION_PROBE_TYPE_NONE 0\\n#define REFLECTION_PROBE_TYPE_CUBE 1\\n#define REFLECTION_PROBE_TYPE_PLANAR 2\\n#define REFLECTION_PROBE_TYPE_BLEND 3\\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\\n#define LIGHT_TYPE_DIRECTIONAL 0.0\\n#define LIGHT_TYPE_SPHERE 1.0\\n#define LIGHT_TYPE_SPOT 2.0\\n#define LIGHT_TYPE_POINT 3.0\\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\\n#define TONE_MAPPING_ACES 0\\n#define TONE_MAPPING_LINEAR 1\\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\\n#endif\\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\\n#endif\\nstruct StandardVertInput {\\n  highp vec4 position;\\n  vec3 normal;\\n  vec4 tangent;\\n};\\nattribute vec3 a_position;\\nattribute vec3 a_normal;\\nattribute vec2 a_texCoord;\\nattribute vec4 a_tangent;\\n#if CC_USE_SKINNING\\n    attribute vec4 a_joints;\\n  attribute vec4 a_weights;\\n#endif\\n#if USE_INSTANCING\\n  #if CC_USE_BAKED_ANIMATION\\n    attribute highp vec4 a_jointAnimInfo;\\n  #endif\\n  attribute vec4 a_matWorld0;\\n  attribute vec4 a_matWorld1;\\n  attribute vec4 a_matWorld2;\\n  #if CC_USE_LIGHTMAP\\n    attribute vec4 a_lightingMapUVParam;\\n  #endif\\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\\n    #if CC_RECEIVE_SHADOW\\n    #endif\\n    attribute vec4 a_localShadowBiasAndProbeId;\\n  #endif\\n  #if CC_USE_REFLECTION_PROBE\\n    attribute vec4 a_reflectionProbeData;\\n  #endif\\n  #if CC_USE_LIGHT_PROBE\\n    attribute vec4 a_sh_linear_const_r;\\n    attribute vec4 a_sh_linear_const_g;\\n    attribute vec4 a_sh_linear_const_b;\\n  #endif\\n#endif\\n#if CC_USE_MORPH\\n    attribute float a_vertexId;\\n    int getVertexId() {\\n      return int(a_vertexId);\\n    }\\n#endif\\nhighp float decode32 (highp vec4 rgba) {\\n  rgba = rgba * 255.0;\\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\\n}\\n#if CC_USE_MORPH\\n  uniform vec4 cc_displacementWeights[15];\\n  uniform vec4 cc_displacementTextureInfo;\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    uniform sampler2D cc_PositionDisplacements;\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n    uniform sampler2D cc_NormalDisplacements;\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n    uniform sampler2D cc_TangentDisplacements;\\n  #endif\\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\\n    float pixelIndexF = float(pixelIndex);\\n    float x = mod(pixelIndexF, textureResolution.x);\\n    float y = floor(pixelIndexF / textureResolution.x);\\n    return vec2(x, y);\\n  }\\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\\n    return (vec2(location.x, location.y) + .5) / textureResolution;\\n  }\\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\\n        int pixelIndex = elementIndex;\\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\\n        return texture2D(tex, uv);\\n      }\\n  #else\\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\\n      int pixelIndex = elementIndex * 4;\\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\\n      return vec4(\\n        decode32(texture2D(tex, x)),\\n        decode32(texture2D(tex, y)),\\n        decode32(texture2D(tex, z)),\\n        1.0\\n      );\\n    }\\n  #endif\\n  float getDisplacementWeight(int index) {\\n    int quot = index / 4;\\n    int remainder = index - quot * 4;\\n    if (remainder == 0) {\\n      return cc_displacementWeights[quot].x;\\n    } else if (remainder == 1) {\\n      return cc_displacementWeights[quot].y;\\n    } else if (remainder == 2) {\\n      return cc_displacementWeights[quot].z;\\n    } else {\\n      return cc_displacementWeights[quot].w;\\n    }\\n  }\\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\\n  #if CC_MORPH_PRECOMPUTED\\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\\n  #else\\n    vec3 result = vec3(0, 0, 0);\\n    int nVertices = int(cc_displacementTextureInfo.z);\\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\\n    }\\n    return result;\\n  #endif\\n  }\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n  vec3 getPositionDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\\n  }\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n  vec3 getNormalDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\\n  }\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n  vec3 getTangentDisplacement(int vertexId) {\\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\\n  }\\n  #endif\\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\\n    int vertexId = getVertexId();\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_NORMAL\\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\\n  #endif\\n  #if CC_MORPH_TARGET_HAS_TANGENT\\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\\n  #endif\\n  }\\n  void applyMorph (inout vec4 position) {\\n  #if CC_MORPH_TARGET_HAS_POSITION\\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\\n  #endif\\n  }\\n#endif\\n#if CC_USE_SKINNING\\n  #if CC_USE_BAKED_ANIMATION\\n    uniform highp vec4 cc_jointTextureInfo;\\n    uniform highp vec4 cc_jointAnimInfo;\\n    uniform highp sampler2D cc_jointTexture;\\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\\n    {\\n      #if USE_INSTANCING\\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\\n      #else\\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\\n      #endif\\n      invSize = cc_jointTextureInfo.w;\\n      highp float tempY = floor(temp * invSize);\\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\\n      y = (tempY + 0.5) * invSize;\\n    }\\n  #else\\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\\n      uniform highp sampler2D cc_realtimeJoint;\\n    #else\\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\\n    #endif\\n  #endif\\n  #if CC_USE_BAKED_ANIMATION\\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n      mat4 getJointMatrix (float i) {\\n        highp float x, y, invSize;\\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #else\\n      mat4 getJointMatrix (float i) {\\n        highp float x, y, invSize;\\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\\n        vec4 v1 = vec4(\\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\\n        );\\n        vec4 v2 = vec4(\\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\\n        );\\n        vec4 v3 = vec4(\\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\\n        );\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #endif\\n  #else\\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\\n        mat4 getJointMatrix (float i) {\\n          float x = i;\\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n        }\\n      #else\\n        mat4 getJointMatrix (float i) {\\n         float x = 4.0 * i;\\n          vec4 v1 = vec4(\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\\n          );\\n          vec4 v2 = vec4(\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\\n          );\\n          vec4 v3 = vec4(\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\\n          );\\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n        }\\n      #endif\\n    #else\\n      mat4 getJointMatrix (float i) {\\n        int idx = int(i);\\n        vec4 v1 = cc_joints[idx * 3];\\n        vec4 v2 = cc_joints[idx * 3 + 1];\\n        vec4 v3 = cc_joints[idx * 3 + 2];\\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\\n      }\\n    #endif\\n  #endif\\n  mat4 skinMatrix () {\\n    vec4 joints = vec4(a_joints);\\n    return getJointMatrix(joints.x) * a_weights.x\\n         + getJointMatrix(joints.y) * a_weights.y\\n         + getJointMatrix(joints.z) * a_weights.z\\n         + getJointMatrix(joints.w) * a_weights.w;\\n  }\\n  void CCSkin (inout vec4 position) {\\n    mat4 m = skinMatrix();\\n    position = m * position;\\n  }\\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\\n    mat4 m = skinMatrix();\\n    position = m * position;\\n    normal = (m * vec4(normal, 0.0)).xyz;\\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\\n  }\\n#endif\\nvoid CCVertInput(inout StandardVertInput In)\\n{\\n    In.position = vec4(a_position, 1.0);\\n    In.normal = a_normal;\\n    In.tangent = a_tangent;\\n  #if CC_USE_MORPH\\n    applyMorph(In.position, In.normal, In.tangent);\\n  #endif\\n  #if CC_USE_SKINNING\\n    CCSkin(In.position, In.normal, In.tangent);\\n  #endif\\n}\\nuniform highp mat4 cc_matView;\\n  uniform highp mat4 cc_matProj;\\n#if !USE_INSTANCING\\n  uniform highp mat4 cc_matWorld;\\n  uniform highp mat4 cc_matWorldIT;\\n#endif\\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\\n{\\n  #if USE_INSTANCING\\n    matWorld = mat4(\\n      vec4(a_matWorld0.xyz, 0.0),\\n      vec4(a_matWorld1.xyz, 0.0),\\n      vec4(a_matWorld2.xyz, 0.0),\\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\\n    );\\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\\n    vec3 scale2 = scale * scale;\\n    matWorldIT = mat4(\\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\\n      vec4(0.0, 0.0, 0.0, 1.0)\\n    );\\n  #else\\n    matWorld = cc_matWorld;\\n    matWorldIT = cc_matWorldIT;\\n  #endif\\n}\\nvarying vec2 v_uv;\\nvarying vec2 v_texCoord;\\nvec4 vert () {\\n  StandardVertInput In;\\n  CCVertInput(In);\\n  mat4 matWorld, matWorldIT;\\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\\n  v_uv = a_texCoord;\\n  v_texCoord = a_texCoord;\\n  return cc_matProj * (cc_matView * matWorld) * In.position;\\n}\\nvoid main() { gl_Position = vert(); }","frag":"\\n#extension GL_OES_standard_derivatives : enable\\nprecision highp float;\\nvec4 CCFragOutput (vec4 color) {\\n  return color;\\n}\\nvarying vec2 v_uv;\\nvarying vec2 v_texCoord;\\n   uniform vec4 mainColor;\\n   uniform vec4 lineColor;\\n   uniform vec4 rimColor;\\n   uniform vec4 gridParams;\\nfloat grid(float width, vec2 step, vec2 pos){\\n    vec2 coord = pos / step;\\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord * width);\\n    float line = min(grid.x, grid.y);\\n    return 1. - min(line, 1.0);\\n}\\nvec4 frag () {\\n  float scale = gridParams.w;\\n  float v = grid(1.0, vec2(0.1 * scale), v_uv) * gridParams.x\\n          + grid(1.0, vec2(5.0 * scale), v_uv * 10.0) * gridParams.y;\\n  vec3 c = v * lineColor.rgb;\\n  c = mix(mainColor.rgb, c, v);\\n  float dist = length(v_texCoord - vec2(0.5, 0.5)) * 2.;\\n  c = mix(rimColor.rgb, c, smoothstep(rimColor.a, 0.0, dist));\\n  return CCFragOutput(vec4(c, mainColor.a));\\n}\\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":74,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":46}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"../gridEffect/gridEffect|unlit-vs:vert|unlit-fs:frag","properties":{"mainColor":{"type":16,"value":[0.9,0.9,0.9,1]},"lineColor":{"type":16,"value":[0.765,0.765,0.765,1]},"rimColor":{"type":16,"value":[1,1,1,0.8]},"grid1Intensity":{"type":13,"value":[0.15],"handleInfo":["gridParams",0,13]},"grid2Intensity":{"type":13,"value":[0.5],"handleInfo":["gridParams",1,13]},"gridScale":{"type":13,"value":[1],"handleInfo":["gridParams",3,13]},"gridParams":{"type":16,"value":[0.15,0.5,0,1]}}}]},{"name":"transparent","passes":[{"program":"../gridEffect/gridEffect|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainColor":{"type":16,"value":[0.9,0.9,0.9,1]},"lineColor":{"type":16,"value":[0.765,0.765,0.765,1]},"rimColor":{"type":16,"value":[1,1,1,0.8]},"grid1Intensity":{"type":13,"value":[0.15],"handleInfo":["gridParams",0,13]},"grid2Intensity":{"type":13,"value":[0.5],"handleInfo":["gridParams",1,13]},"gridScale":{"type":13,"value":[1],"handleInfo":["gridParams",3,13]},"gridParams":{"type":16,"value":[0.15,0.5,0,1]}}}]}]]],0,0,[],[],[]]');m.onLoaded();const A=l.model.modelBounds.halfExtents.length();let _=Math.ceil(A);a.near=A/100,a.far=100*A;const g=new t.Node("Ground"),v=t.primitives.plane({width:100*_,length:100*_,widthSegments:10,lengthSegments:10}),p=g.addComponent("cc.MeshRenderer"),u=new t.Material;u.initialize({effectAsset:m,technique:1,defines:{ENABLE_GRID:!0,ENABLE_FOG:!0}}),u.setProperty("mainColor",new t.Color("FFFFFFC8")),u.setProperty("gridScale",.1/_),u.setProperty("rimColor",new t.Color("C2C2C244")),p.setSharedMaterial(u,0),p.mesh=t.utils.MeshUtils.createMesh(v),g.setPosition(0,-A/1e4,0),i.addChild(g);const C=new N(this,l),E=new R(this,i,c,d);this.modules.push(new T(this,i)),this.modules.push(new y(this,i,l)),this.modules.push(new S(this,i,a,l)),this.modules.push(C),this.modules.push(new P(this,c)),this.modules.push(new M(this,i,o,c,d)),this.modules.push(E);for(const e of this.modules)e.initialize();const I={transform:{id:h(null!=l.skeleton?l.skeleton.uuid:l.mesh.uuid)},material:C.getMaterialData(),animation:E.getAnimationData()};this.dispatch(O.ReadyEvent,I),this.on(O.ModuleEnableEvent,this.onGridEnable,this)}onGridEnable(e,n){if("grid"!=e)return;t.director.getScene().getChildByName("Ground").getComponent("cc.MeshRenderer").material.recompileShaders({ENABLE_GRID:n})}setMaterial(n,i=0){return e(this,void 0,void 0,(function*(){let e;"string"==typeof n&&(n=yield O.loadAsset(t.Material,n));for(const t of this.modules)t instanceof N?(e=t,t.setMaterial(n,i)):t instanceof M&&t.setMaterial(n,i);return e.getMaterialData()}))}setAnimation(n){return e(this,void 0,void 0,(function*(){if("string"==typeof n){let e=yield O.loadAsset(t.AnimationClip,n);e instanceof t.Prefab&&(e=e.data.getComponent(t.Animation).clips[0]),e.name=n,n=e}let e;for(const t of this.modules)t instanceof R?(e=t,t.setAnimation(n)):t instanceof M&&t.setAnimation(n);return null==n?null:e.getAnimationData()}))}moduleEnabled(e,t){this.dispatch(O.ModuleEnableEvent,e,t)}finalize(){this.off(O.ModuleEnableEvent,this.onGridEnable,this),globalThis.MV_PLAYABLE=!0;for(const e of this.modules)e.finalize()}}O.ReadyEvent=class{constructor(e){}},O.ModuleEnableEvent=class{constructor(e,t){}},O.TransformEvent=class{constructor(e,t,n){}},O.HsvEvent=class{constructor(e,t,n){}},O.ShaderParamEvent=class{constructor(e,t){}},O.OperationEvent=class{constructor(e){}},O.AnimationSpeedChangedEvent=class{constructor(e){}},O.AnimationEventChangedEvent=class{constructor(e,t){}},O.OnAnimationEventChangedEvent=class{constructor(e,t,n){}},O.version="1.4";